// Code generated by entc, DO NOT EDIT.

package ent

import (
	"comment/app/job/internal/data/ent/commentcontent"
	"comment/app/job/internal/data/ent/commentindex"
	"comment/app/job/internal/data/ent/commentsubject"
	"comment/app/job/internal/data/ent/predicate"
	"context"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCommentContent = "CommentContent"
	TypeCommentIndex   = "CommentIndex"
	TypeCommentSubject = "CommentSubject"
)

// CommentContentMutation represents an operation that mutates the CommentContent nodes in the graph.
type CommentContentMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	obj_id        *int64
	addobj_id     *int64
	owner_id      *int64
	addowner_id   *int64
	root          *int64
	addroot       *int64
	floor         *int32
	addfloor      *int32
	message       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CommentContent, error)
	predicates    []predicate.CommentContent
}

var _ ent.Mutation = (*CommentContentMutation)(nil)

// commentcontentOption allows management of the mutation configuration using functional options.
type commentcontentOption func(*CommentContentMutation)

// newCommentContentMutation creates new mutation for the CommentContent entity.
func newCommentContentMutation(c config, op Op, opts ...commentcontentOption) *CommentContentMutation {
	m := &CommentContentMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentContentID sets the ID field of the mutation.
func withCommentContentID(id int64) commentcontentOption {
	return func(m *CommentContentMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentContent
		)
		m.oldValue = func(ctx context.Context) (*CommentContent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentContent sets the old CommentContent of the mutation.
func withCommentContent(node *CommentContent) commentcontentOption {
	return func(m *CommentContentMutation) {
		m.oldValue = func(context.Context) (*CommentContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentContent entities.
func (m *CommentContentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentContentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetObjID sets the "obj_id" field.
func (m *CommentContentMutation) SetObjID(i int64) {
	m.obj_id = &i
	m.addobj_id = nil
}

// ObjID returns the value of the "obj_id" field in the mutation.
func (m *CommentContentMutation) ObjID() (r int64, exists bool) {
	v := m.obj_id
	if v == nil {
		return
	}
	return *v, true
}

// OldObjID returns the old "obj_id" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldObjID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldObjID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldObjID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjID: %w", err)
	}
	return oldValue.ObjID, nil
}

// AddObjID adds i to the "obj_id" field.
func (m *CommentContentMutation) AddObjID(i int64) {
	if m.addobj_id != nil {
		*m.addobj_id += i
	} else {
		m.addobj_id = &i
	}
}

// AddedObjID returns the value that was added to the "obj_id" field in this mutation.
func (m *CommentContentMutation) AddedObjID() (r int64, exists bool) {
	v := m.addobj_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetObjID resets all changes to the "obj_id" field.
func (m *CommentContentMutation) ResetObjID() {
	m.obj_id = nil
	m.addobj_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *CommentContentMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CommentContentMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *CommentContentMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *CommentContentMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CommentContentMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetRoot sets the "root" field.
func (m *CommentContentMutation) SetRoot(i int64) {
	m.root = &i
	m.addroot = nil
}

// Root returns the value of the "root" field in the mutation.
func (m *CommentContentMutation) Root() (r int64, exists bool) {
	v := m.root
	if v == nil {
		return
	}
	return *v, true
}

// OldRoot returns the old "root" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldRoot(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoot: %w", err)
	}
	return oldValue.Root, nil
}

// AddRoot adds i to the "root" field.
func (m *CommentContentMutation) AddRoot(i int64) {
	if m.addroot != nil {
		*m.addroot += i
	} else {
		m.addroot = &i
	}
}

// AddedRoot returns the value that was added to the "root" field in this mutation.
func (m *CommentContentMutation) AddedRoot() (r int64, exists bool) {
	v := m.addroot
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoot resets all changes to the "root" field.
func (m *CommentContentMutation) ResetRoot() {
	m.root = nil
	m.addroot = nil
}

// SetFloor sets the "floor" field.
func (m *CommentContentMutation) SetFloor(i int32) {
	m.floor = &i
	m.addfloor = nil
}

// Floor returns the value of the "floor" field in the mutation.
func (m *CommentContentMutation) Floor() (r int32, exists bool) {
	v := m.floor
	if v == nil {
		return
	}
	return *v, true
}

// OldFloor returns the old "floor" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldFloor(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloor: %w", err)
	}
	return oldValue.Floor, nil
}

// AddFloor adds i to the "floor" field.
func (m *CommentContentMutation) AddFloor(i int32) {
	if m.addfloor != nil {
		*m.addfloor += i
	} else {
		m.addfloor = &i
	}
}

// AddedFloor returns the value that was added to the "floor" field in this mutation.
func (m *CommentContentMutation) AddedFloor() (r int32, exists bool) {
	v := m.addfloor
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloor resets all changes to the "floor" field.
func (m *CommentContentMutation) ResetFloor() {
	m.floor = nil
	m.addfloor = nil
}

// SetMessage sets the "message" field.
func (m *CommentContentMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CommentContentMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CommentContentMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentContent entity.
// If the CommentContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommentContentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[commentcontent.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommentContentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[commentcontent.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, commentcontent.FieldUpdatedAt)
}

// Where appends a list predicates to the CommentContentMutation builder.
func (m *CommentContentMutation) Where(ps ...predicate.CommentContent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentContentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CommentContent).
func (m *CommentContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.obj_id != nil {
		fields = append(fields, commentcontent.FieldObjID)
	}
	if m.owner_id != nil {
		fields = append(fields, commentcontent.FieldOwnerID)
	}
	if m.root != nil {
		fields = append(fields, commentcontent.FieldRoot)
	}
	if m.floor != nil {
		fields = append(fields, commentcontent.FieldFloor)
	}
	if m.message != nil {
		fields = append(fields, commentcontent.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, commentcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commentcontent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentcontent.FieldObjID:
		return m.ObjID()
	case commentcontent.FieldOwnerID:
		return m.OwnerID()
	case commentcontent.FieldRoot:
		return m.Root()
	case commentcontent.FieldFloor:
		return m.Floor()
	case commentcontent.FieldMessage:
		return m.Message()
	case commentcontent.FieldCreatedAt:
		return m.CreatedAt()
	case commentcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentcontent.FieldObjID:
		return m.OldObjID(ctx)
	case commentcontent.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case commentcontent.FieldRoot:
		return m.OldRoot(ctx)
	case commentcontent.FieldFloor:
		return m.OldFloor(ctx)
	case commentcontent.FieldMessage:
		return m.OldMessage(ctx)
	case commentcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commentcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CommentContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentcontent.FieldObjID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjID(v)
		return nil
	case commentcontent.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case commentcontent.FieldRoot:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoot(v)
		return nil
	case commentcontent.FieldFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloor(v)
		return nil
	case commentcontent.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case commentcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commentcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CommentContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentContentMutation) AddedFields() []string {
	var fields []string
	if m.addobj_id != nil {
		fields = append(fields, commentcontent.FieldObjID)
	}
	if m.addowner_id != nil {
		fields = append(fields, commentcontent.FieldOwnerID)
	}
	if m.addroot != nil {
		fields = append(fields, commentcontent.FieldRoot)
	}
	if m.addfloor != nil {
		fields = append(fields, commentcontent.FieldFloor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentContentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentcontent.FieldObjID:
		return m.AddedObjID()
	case commentcontent.FieldOwnerID:
		return m.AddedOwnerID()
	case commentcontent.FieldRoot:
		return m.AddedRoot()
	case commentcontent.FieldFloor:
		return m.AddedFloor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentcontent.FieldObjID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddObjID(v)
		return nil
	case commentcontent.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case commentcontent.FieldRoot:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoot(v)
		return nil
	case commentcontent.FieldFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloor(v)
		return nil
	}
	return fmt.Errorf("unknown CommentContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commentcontent.FieldUpdatedAt) {
		fields = append(fields, commentcontent.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentContentMutation) ClearField(name string) error {
	switch name {
	case commentcontent.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommentContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentContentMutation) ResetField(name string) error {
	switch name {
	case commentcontent.FieldObjID:
		m.ResetObjID()
		return nil
	case commentcontent.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case commentcontent.FieldRoot:
		m.ResetRoot()
		return nil
	case commentcontent.FieldFloor:
		m.ResetFloor()
		return nil
	case commentcontent.FieldMessage:
		m.ResetMessage()
		return nil
	case commentcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commentcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommentContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentContentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentContentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentContentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommentContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentContentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommentContent edge %s", name)
}

// CommentIndexMutation represents an operation that mutates the CommentIndex nodes in the graph.
type CommentIndexMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	content_id    *int64
	addcontent_id *int64
	obj_id        *int64
	addobj_id     *int64
	owner_id      *int64
	addowner_id   *int64
	root          *int64
	addroot       *int64
	parent        *int64
	addparent     *int64
	floor         *int32
	addfloor      *int32
	like          *int32
	addlike       *int32
	hate          *int32
	addhate       *int32
	state         *int8
	addstate      *int8
	created_at    *time.Time
	updated_at    *time.Time
	next_floor    *int32
	addnext_floor *int32
	count         *int32
	addcount      *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CommentIndex, error)
	predicates    []predicate.CommentIndex
}

var _ ent.Mutation = (*CommentIndexMutation)(nil)

// commentindexOption allows management of the mutation configuration using functional options.
type commentindexOption func(*CommentIndexMutation)

// newCommentIndexMutation creates new mutation for the CommentIndex entity.
func newCommentIndexMutation(c config, op Op, opts ...commentindexOption) *CommentIndexMutation {
	m := &CommentIndexMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentIndex,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentIndexID sets the ID field of the mutation.
func withCommentIndexID(id int64) commentindexOption {
	return func(m *CommentIndexMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentIndex
		)
		m.oldValue = func(ctx context.Context) (*CommentIndex, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentIndex.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentIndex sets the old CommentIndex of the mutation.
func withCommentIndex(node *CommentIndex) commentindexOption {
	return func(m *CommentIndexMutation) {
		m.oldValue = func(context.Context) (*CommentIndex, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentIndexMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentIndexMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentIndex entities.
func (m *CommentIndexMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentIndexMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetContentID sets the "content_id" field.
func (m *CommentIndexMutation) SetContentID(i int64) {
	m.content_id = &i
	m.addcontent_id = nil
}

// ContentID returns the value of the "content_id" field in the mutation.
func (m *CommentIndexMutation) ContentID() (r int64, exists bool) {
	v := m.content_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContentID returns the old "content_id" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldContentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentID: %w", err)
	}
	return oldValue.ContentID, nil
}

// AddContentID adds i to the "content_id" field.
func (m *CommentIndexMutation) AddContentID(i int64) {
	if m.addcontent_id != nil {
		*m.addcontent_id += i
	} else {
		m.addcontent_id = &i
	}
}

// AddedContentID returns the value that was added to the "content_id" field in this mutation.
func (m *CommentIndexMutation) AddedContentID() (r int64, exists bool) {
	v := m.addcontent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetContentID resets all changes to the "content_id" field.
func (m *CommentIndexMutation) ResetContentID() {
	m.content_id = nil
	m.addcontent_id = nil
}

// SetObjID sets the "obj_id" field.
func (m *CommentIndexMutation) SetObjID(i int64) {
	m.obj_id = &i
	m.addobj_id = nil
}

// ObjID returns the value of the "obj_id" field in the mutation.
func (m *CommentIndexMutation) ObjID() (r int64, exists bool) {
	v := m.obj_id
	if v == nil {
		return
	}
	return *v, true
}

// OldObjID returns the old "obj_id" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldObjID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldObjID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldObjID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjID: %w", err)
	}
	return oldValue.ObjID, nil
}

// AddObjID adds i to the "obj_id" field.
func (m *CommentIndexMutation) AddObjID(i int64) {
	if m.addobj_id != nil {
		*m.addobj_id += i
	} else {
		m.addobj_id = &i
	}
}

// AddedObjID returns the value that was added to the "obj_id" field in this mutation.
func (m *CommentIndexMutation) AddedObjID() (r int64, exists bool) {
	v := m.addobj_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetObjID resets all changes to the "obj_id" field.
func (m *CommentIndexMutation) ResetObjID() {
	m.obj_id = nil
	m.addobj_id = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *CommentIndexMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CommentIndexMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *CommentIndexMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *CommentIndexMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CommentIndexMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetRoot sets the "root" field.
func (m *CommentIndexMutation) SetRoot(i int64) {
	m.root = &i
	m.addroot = nil
}

// Root returns the value of the "root" field in the mutation.
func (m *CommentIndexMutation) Root() (r int64, exists bool) {
	v := m.root
	if v == nil {
		return
	}
	return *v, true
}

// OldRoot returns the old "root" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldRoot(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoot: %w", err)
	}
	return oldValue.Root, nil
}

// AddRoot adds i to the "root" field.
func (m *CommentIndexMutation) AddRoot(i int64) {
	if m.addroot != nil {
		*m.addroot += i
	} else {
		m.addroot = &i
	}
}

// AddedRoot returns the value that was added to the "root" field in this mutation.
func (m *CommentIndexMutation) AddedRoot() (r int64, exists bool) {
	v := m.addroot
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoot resets all changes to the "root" field.
func (m *CommentIndexMutation) ResetRoot() {
	m.root = nil
	m.addroot = nil
}

// SetParent sets the "parent" field.
func (m *CommentIndexMutation) SetParent(i int64) {
	m.parent = &i
	m.addparent = nil
}

// Parent returns the value of the "parent" field in the mutation.
func (m *CommentIndexMutation) Parent() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParent returns the old "parent" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldParent(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParent: %w", err)
	}
	return oldValue.Parent, nil
}

// AddParent adds i to the "parent" field.
func (m *CommentIndexMutation) AddParent(i int64) {
	if m.addparent != nil {
		*m.addparent += i
	} else {
		m.addparent = &i
	}
}

// AddedParent returns the value that was added to the "parent" field in this mutation.
func (m *CommentIndexMutation) AddedParent() (r int64, exists bool) {
	v := m.addparent
	if v == nil {
		return
	}
	return *v, true
}

// ResetParent resets all changes to the "parent" field.
func (m *CommentIndexMutation) ResetParent() {
	m.parent = nil
	m.addparent = nil
}

// SetFloor sets the "floor" field.
func (m *CommentIndexMutation) SetFloor(i int32) {
	m.floor = &i
	m.addfloor = nil
}

// Floor returns the value of the "floor" field in the mutation.
func (m *CommentIndexMutation) Floor() (r int32, exists bool) {
	v := m.floor
	if v == nil {
		return
	}
	return *v, true
}

// OldFloor returns the old "floor" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldFloor(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloor: %w", err)
	}
	return oldValue.Floor, nil
}

// AddFloor adds i to the "floor" field.
func (m *CommentIndexMutation) AddFloor(i int32) {
	if m.addfloor != nil {
		*m.addfloor += i
	} else {
		m.addfloor = &i
	}
}

// AddedFloor returns the value that was added to the "floor" field in this mutation.
func (m *CommentIndexMutation) AddedFloor() (r int32, exists bool) {
	v := m.addfloor
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloor resets all changes to the "floor" field.
func (m *CommentIndexMutation) ResetFloor() {
	m.floor = nil
	m.addfloor = nil
}

// SetLike sets the "like" field.
func (m *CommentIndexMutation) SetLike(i int32) {
	m.like = &i
	m.addlike = nil
}

// Like returns the value of the "like" field in the mutation.
func (m *CommentIndexMutation) Like() (r int32, exists bool) {
	v := m.like
	if v == nil {
		return
	}
	return *v, true
}

// OldLike returns the old "like" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldLike(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLike is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLike requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLike: %w", err)
	}
	return oldValue.Like, nil
}

// AddLike adds i to the "like" field.
func (m *CommentIndexMutation) AddLike(i int32) {
	if m.addlike != nil {
		*m.addlike += i
	} else {
		m.addlike = &i
	}
}

// AddedLike returns the value that was added to the "like" field in this mutation.
func (m *CommentIndexMutation) AddedLike() (r int32, exists bool) {
	v := m.addlike
	if v == nil {
		return
	}
	return *v, true
}

// ResetLike resets all changes to the "like" field.
func (m *CommentIndexMutation) ResetLike() {
	m.like = nil
	m.addlike = nil
}

// SetHate sets the "hate" field.
func (m *CommentIndexMutation) SetHate(i int32) {
	m.hate = &i
	m.addhate = nil
}

// Hate returns the value of the "hate" field in the mutation.
func (m *CommentIndexMutation) Hate() (r int32, exists bool) {
	v := m.hate
	if v == nil {
		return
	}
	return *v, true
}

// OldHate returns the old "hate" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldHate(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHate: %w", err)
	}
	return oldValue.Hate, nil
}

// AddHate adds i to the "hate" field.
func (m *CommentIndexMutation) AddHate(i int32) {
	if m.addhate != nil {
		*m.addhate += i
	} else {
		m.addhate = &i
	}
}

// AddedHate returns the value that was added to the "hate" field in this mutation.
func (m *CommentIndexMutation) AddedHate() (r int32, exists bool) {
	v := m.addhate
	if v == nil {
		return
	}
	return *v, true
}

// ResetHate resets all changes to the "hate" field.
func (m *CommentIndexMutation) ResetHate() {
	m.hate = nil
	m.addhate = nil
}

// SetState sets the "state" field.
func (m *CommentIndexMutation) SetState(i int8) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CommentIndexMutation) State() (r int8, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldState(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CommentIndexMutation) AddState(i int8) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CommentIndexMutation) AddedState() (r int8, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CommentIndexMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentIndexMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentIndexMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentIndexMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentIndexMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentIndexMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommentIndexMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[commentindex.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommentIndexMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[commentindex.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentIndexMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, commentindex.FieldUpdatedAt)
}

// SetNextFloor sets the "next_floor" field.
func (m *CommentIndexMutation) SetNextFloor(i int32) {
	m.next_floor = &i
	m.addnext_floor = nil
}

// NextFloor returns the value of the "next_floor" field in the mutation.
func (m *CommentIndexMutation) NextFloor() (r int32, exists bool) {
	v := m.next_floor
	if v == nil {
		return
	}
	return *v, true
}

// OldNextFloor returns the old "next_floor" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldNextFloor(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNextFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNextFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextFloor: %w", err)
	}
	return oldValue.NextFloor, nil
}

// AddNextFloor adds i to the "next_floor" field.
func (m *CommentIndexMutation) AddNextFloor(i int32) {
	if m.addnext_floor != nil {
		*m.addnext_floor += i
	} else {
		m.addnext_floor = &i
	}
}

// AddedNextFloor returns the value that was added to the "next_floor" field in this mutation.
func (m *CommentIndexMutation) AddedNextFloor() (r int32, exists bool) {
	v := m.addnext_floor
	if v == nil {
		return
	}
	return *v, true
}

// ClearNextFloor clears the value of the "next_floor" field.
func (m *CommentIndexMutation) ClearNextFloor() {
	m.next_floor = nil
	m.addnext_floor = nil
	m.clearedFields[commentindex.FieldNextFloor] = struct{}{}
}

// NextFloorCleared returns if the "next_floor" field was cleared in this mutation.
func (m *CommentIndexMutation) NextFloorCleared() bool {
	_, ok := m.clearedFields[commentindex.FieldNextFloor]
	return ok
}

// ResetNextFloor resets all changes to the "next_floor" field.
func (m *CommentIndexMutation) ResetNextFloor() {
	m.next_floor = nil
	m.addnext_floor = nil
	delete(m.clearedFields, commentindex.FieldNextFloor)
}

// SetCount sets the "count" field.
func (m *CommentIndexMutation) SetCount(i int32) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *CommentIndexMutation) Count() (r int32, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the CommentIndex entity.
// If the CommentIndex object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentIndexMutation) OldCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *CommentIndexMutation) AddCount(i int32) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *CommentIndexMutation) AddedCount() (r int32, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *CommentIndexMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// Where appends a list predicates to the CommentIndexMutation builder.
func (m *CommentIndexMutation) Where(ps ...predicate.CommentIndex) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentIndexMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CommentIndex).
func (m *CommentIndexMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentIndexMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.content_id != nil {
		fields = append(fields, commentindex.FieldContentID)
	}
	if m.obj_id != nil {
		fields = append(fields, commentindex.FieldObjID)
	}
	if m.owner_id != nil {
		fields = append(fields, commentindex.FieldOwnerID)
	}
	if m.root != nil {
		fields = append(fields, commentindex.FieldRoot)
	}
	if m.parent != nil {
		fields = append(fields, commentindex.FieldParent)
	}
	if m.floor != nil {
		fields = append(fields, commentindex.FieldFloor)
	}
	if m.like != nil {
		fields = append(fields, commentindex.FieldLike)
	}
	if m.hate != nil {
		fields = append(fields, commentindex.FieldHate)
	}
	if m.state != nil {
		fields = append(fields, commentindex.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, commentindex.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commentindex.FieldUpdatedAt)
	}
	if m.next_floor != nil {
		fields = append(fields, commentindex.FieldNextFloor)
	}
	if m.count != nil {
		fields = append(fields, commentindex.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentIndexMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentindex.FieldContentID:
		return m.ContentID()
	case commentindex.FieldObjID:
		return m.ObjID()
	case commentindex.FieldOwnerID:
		return m.OwnerID()
	case commentindex.FieldRoot:
		return m.Root()
	case commentindex.FieldParent:
		return m.Parent()
	case commentindex.FieldFloor:
		return m.Floor()
	case commentindex.FieldLike:
		return m.Like()
	case commentindex.FieldHate:
		return m.Hate()
	case commentindex.FieldState:
		return m.State()
	case commentindex.FieldCreatedAt:
		return m.CreatedAt()
	case commentindex.FieldUpdatedAt:
		return m.UpdatedAt()
	case commentindex.FieldNextFloor:
		return m.NextFloor()
	case commentindex.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentIndexMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentindex.FieldContentID:
		return m.OldContentID(ctx)
	case commentindex.FieldObjID:
		return m.OldObjID(ctx)
	case commentindex.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case commentindex.FieldRoot:
		return m.OldRoot(ctx)
	case commentindex.FieldParent:
		return m.OldParent(ctx)
	case commentindex.FieldFloor:
		return m.OldFloor(ctx)
	case commentindex.FieldLike:
		return m.OldLike(ctx)
	case commentindex.FieldHate:
		return m.OldHate(ctx)
	case commentindex.FieldState:
		return m.OldState(ctx)
	case commentindex.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commentindex.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commentindex.FieldNextFloor:
		return m.OldNextFloor(ctx)
	case commentindex.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown CommentIndex field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentIndexMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentindex.FieldContentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentID(v)
		return nil
	case commentindex.FieldObjID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjID(v)
		return nil
	case commentindex.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case commentindex.FieldRoot:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoot(v)
		return nil
	case commentindex.FieldParent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParent(v)
		return nil
	case commentindex.FieldFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloor(v)
		return nil
	case commentindex.FieldLike:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLike(v)
		return nil
	case commentindex.FieldHate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHate(v)
		return nil
	case commentindex.FieldState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case commentindex.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commentindex.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commentindex.FieldNextFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextFloor(v)
		return nil
	case commentindex.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown CommentIndex field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentIndexMutation) AddedFields() []string {
	var fields []string
	if m.addcontent_id != nil {
		fields = append(fields, commentindex.FieldContentID)
	}
	if m.addobj_id != nil {
		fields = append(fields, commentindex.FieldObjID)
	}
	if m.addowner_id != nil {
		fields = append(fields, commentindex.FieldOwnerID)
	}
	if m.addroot != nil {
		fields = append(fields, commentindex.FieldRoot)
	}
	if m.addparent != nil {
		fields = append(fields, commentindex.FieldParent)
	}
	if m.addfloor != nil {
		fields = append(fields, commentindex.FieldFloor)
	}
	if m.addlike != nil {
		fields = append(fields, commentindex.FieldLike)
	}
	if m.addhate != nil {
		fields = append(fields, commentindex.FieldHate)
	}
	if m.addstate != nil {
		fields = append(fields, commentindex.FieldState)
	}
	if m.addnext_floor != nil {
		fields = append(fields, commentindex.FieldNextFloor)
	}
	if m.addcount != nil {
		fields = append(fields, commentindex.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentIndexMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentindex.FieldContentID:
		return m.AddedContentID()
	case commentindex.FieldObjID:
		return m.AddedObjID()
	case commentindex.FieldOwnerID:
		return m.AddedOwnerID()
	case commentindex.FieldRoot:
		return m.AddedRoot()
	case commentindex.FieldParent:
		return m.AddedParent()
	case commentindex.FieldFloor:
		return m.AddedFloor()
	case commentindex.FieldLike:
		return m.AddedLike()
	case commentindex.FieldHate:
		return m.AddedHate()
	case commentindex.FieldState:
		return m.AddedState()
	case commentindex.FieldNextFloor:
		return m.AddedNextFloor()
	case commentindex.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentIndexMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentindex.FieldContentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentID(v)
		return nil
	case commentindex.FieldObjID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddObjID(v)
		return nil
	case commentindex.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case commentindex.FieldRoot:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoot(v)
		return nil
	case commentindex.FieldParent:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParent(v)
		return nil
	case commentindex.FieldFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloor(v)
		return nil
	case commentindex.FieldLike:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLike(v)
		return nil
	case commentindex.FieldHate:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHate(v)
		return nil
	case commentindex.FieldState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	case commentindex.FieldNextFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNextFloor(v)
		return nil
	case commentindex.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown CommentIndex numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentIndexMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commentindex.FieldUpdatedAt) {
		fields = append(fields, commentindex.FieldUpdatedAt)
	}
	if m.FieldCleared(commentindex.FieldNextFloor) {
		fields = append(fields, commentindex.FieldNextFloor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentIndexMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentIndexMutation) ClearField(name string) error {
	switch name {
	case commentindex.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case commentindex.FieldNextFloor:
		m.ClearNextFloor()
		return nil
	}
	return fmt.Errorf("unknown CommentIndex nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentIndexMutation) ResetField(name string) error {
	switch name {
	case commentindex.FieldContentID:
		m.ResetContentID()
		return nil
	case commentindex.FieldObjID:
		m.ResetObjID()
		return nil
	case commentindex.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case commentindex.FieldRoot:
		m.ResetRoot()
		return nil
	case commentindex.FieldParent:
		m.ResetParent()
		return nil
	case commentindex.FieldFloor:
		m.ResetFloor()
		return nil
	case commentindex.FieldLike:
		m.ResetLike()
		return nil
	case commentindex.FieldHate:
		m.ResetHate()
		return nil
	case commentindex.FieldState:
		m.ResetState()
		return nil
	case commentindex.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commentindex.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commentindex.FieldNextFloor:
		m.ResetNextFloor()
		return nil
	case commentindex.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown CommentIndex field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentIndexMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentIndexMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentIndexMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentIndexMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentIndexMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentIndexMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentIndexMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommentIndex unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentIndexMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommentIndex edge %s", name)
}

// CommentSubjectMutation represents an operation that mutates the CommentSubject nodes in the graph.
type CommentSubjectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	owner_id      *int64
	addowner_id   *int64
	count         *int32
	addcount      *int32
	next_floor    *int32
	addnext_floor *int32
	state         *int8
	addstate      *int8
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CommentSubject, error)
	predicates    []predicate.CommentSubject
}

var _ ent.Mutation = (*CommentSubjectMutation)(nil)

// commentsubjectOption allows management of the mutation configuration using functional options.
type commentsubjectOption func(*CommentSubjectMutation)

// newCommentSubjectMutation creates new mutation for the CommentSubject entity.
func newCommentSubjectMutation(c config, op Op, opts ...commentsubjectOption) *CommentSubjectMutation {
	m := &CommentSubjectMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentSubject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentSubjectID sets the ID field of the mutation.
func withCommentSubjectID(id int64) commentsubjectOption {
	return func(m *CommentSubjectMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentSubject
		)
		m.oldValue = func(ctx context.Context) (*CommentSubject, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentSubject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentSubject sets the old CommentSubject of the mutation.
func withCommentSubject(node *CommentSubject) commentsubjectOption {
	return func(m *CommentSubjectMutation) {
		m.oldValue = func(context.Context) (*CommentSubject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentSubjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentSubjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentSubject entities.
func (m *CommentSubjectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentSubjectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOwnerID sets the "owner_id" field.
func (m *CommentSubjectMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *CommentSubjectMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *CommentSubjectMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *CommentSubjectMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *CommentSubjectMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
}

// SetCount sets the "count" field.
func (m *CommentSubjectMutation) SetCount(i int32) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *CommentSubjectMutation) Count() (r int32, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *CommentSubjectMutation) AddCount(i int32) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *CommentSubjectMutation) AddedCount() (r int32, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *CommentSubjectMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetNextFloor sets the "next_floor" field.
func (m *CommentSubjectMutation) SetNextFloor(i int32) {
	m.next_floor = &i
	m.addnext_floor = nil
}

// NextFloor returns the value of the "next_floor" field in the mutation.
func (m *CommentSubjectMutation) NextFloor() (r int32, exists bool) {
	v := m.next_floor
	if v == nil {
		return
	}
	return *v, true
}

// OldNextFloor returns the old "next_floor" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldNextFloor(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNextFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNextFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextFloor: %w", err)
	}
	return oldValue.NextFloor, nil
}

// AddNextFloor adds i to the "next_floor" field.
func (m *CommentSubjectMutation) AddNextFloor(i int32) {
	if m.addnext_floor != nil {
		*m.addnext_floor += i
	} else {
		m.addnext_floor = &i
	}
}

// AddedNextFloor returns the value that was added to the "next_floor" field in this mutation.
func (m *CommentSubjectMutation) AddedNextFloor() (r int32, exists bool) {
	v := m.addnext_floor
	if v == nil {
		return
	}
	return *v, true
}

// ResetNextFloor resets all changes to the "next_floor" field.
func (m *CommentSubjectMutation) ResetNextFloor() {
	m.next_floor = nil
	m.addnext_floor = nil
}

// SetState sets the "state" field.
func (m *CommentSubjectMutation) SetState(i int8) {
	m.state = &i
	m.addstate = nil
}

// State returns the value of the "state" field in the mutation.
func (m *CommentSubjectMutation) State() (r int8, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldState(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// AddState adds i to the "state" field.
func (m *CommentSubjectMutation) AddState(i int8) {
	if m.addstate != nil {
		*m.addstate += i
	} else {
		m.addstate = &i
	}
}

// AddedState returns the value that was added to the "state" field in this mutation.
func (m *CommentSubjectMutation) AddedState() (r int8, exists bool) {
	v := m.addstate
	if v == nil {
		return
	}
	return *v, true
}

// ResetState resets all changes to the "state" field.
func (m *CommentSubjectMutation) ResetState() {
	m.state = nil
	m.addstate = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentSubjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentSubjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentSubjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentSubjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentSubjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentSubject entity.
// If the CommentSubject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentSubjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *CommentSubjectMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[commentsubject.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *CommentSubjectMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[commentsubject.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentSubjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, commentsubject.FieldUpdatedAt)
}

// Where appends a list predicates to the CommentSubjectMutation builder.
func (m *CommentSubjectMutation) Where(ps ...predicate.CommentSubject) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommentSubjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CommentSubject).
func (m *CommentSubjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentSubjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner_id != nil {
		fields = append(fields, commentsubject.FieldOwnerID)
	}
	if m.count != nil {
		fields = append(fields, commentsubject.FieldCount)
	}
	if m.next_floor != nil {
		fields = append(fields, commentsubject.FieldNextFloor)
	}
	if m.state != nil {
		fields = append(fields, commentsubject.FieldState)
	}
	if m.created_at != nil {
		fields = append(fields, commentsubject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commentsubject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentSubjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commentsubject.FieldOwnerID:
		return m.OwnerID()
	case commentsubject.FieldCount:
		return m.Count()
	case commentsubject.FieldNextFloor:
		return m.NextFloor()
	case commentsubject.FieldState:
		return m.State()
	case commentsubject.FieldCreatedAt:
		return m.CreatedAt()
	case commentsubject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentSubjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commentsubject.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case commentsubject.FieldCount:
		return m.OldCount(ctx)
	case commentsubject.FieldNextFloor:
		return m.OldNextFloor(ctx)
	case commentsubject.FieldState:
		return m.OldState(ctx)
	case commentsubject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commentsubject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CommentSubject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentSubjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commentsubject.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case commentsubject.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case commentsubject.FieldNextFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextFloor(v)
		return nil
	case commentsubject.FieldState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case commentsubject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commentsubject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CommentSubject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentSubjectMutation) AddedFields() []string {
	var fields []string
	if m.addowner_id != nil {
		fields = append(fields, commentsubject.FieldOwnerID)
	}
	if m.addcount != nil {
		fields = append(fields, commentsubject.FieldCount)
	}
	if m.addnext_floor != nil {
		fields = append(fields, commentsubject.FieldNextFloor)
	}
	if m.addstate != nil {
		fields = append(fields, commentsubject.FieldState)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentSubjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commentsubject.FieldOwnerID:
		return m.AddedOwnerID()
	case commentsubject.FieldCount:
		return m.AddedCount()
	case commentsubject.FieldNextFloor:
		return m.AddedNextFloor()
	case commentsubject.FieldState:
		return m.AddedState()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentSubjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commentsubject.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case commentsubject.FieldCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case commentsubject.FieldNextFloor:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNextFloor(v)
		return nil
	case commentsubject.FieldState:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddState(v)
		return nil
	}
	return fmt.Errorf("unknown CommentSubject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentSubjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commentsubject.FieldUpdatedAt) {
		fields = append(fields, commentsubject.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentSubjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentSubjectMutation) ClearField(name string) error {
	switch name {
	case commentsubject.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommentSubject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentSubjectMutation) ResetField(name string) error {
	switch name {
	case commentsubject.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case commentsubject.FieldCount:
		m.ResetCount()
		return nil
	case commentsubject.FieldNextFloor:
		m.ResetNextFloor()
		return nil
	case commentsubject.FieldState:
		m.ResetState()
		return nil
	case commentsubject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commentsubject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CommentSubject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentSubjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentSubjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentSubjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentSubjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentSubjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentSubjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentSubjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CommentSubject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentSubjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CommentSubject edge %s", name)
}
